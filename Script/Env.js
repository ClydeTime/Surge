function Env(name, opts) {
	return new (class {
		constructor(name, opts) {
			this.name = name
			this.version = '1.7.4'
			this.data = null
			this.logs = []
			this.isMute = false
			this.isNeedRewrite = false
			this.logSeparator = '\n'
			this.encoding = 'utf-8'
			this.startTime = new Date().getTime()
			Object.assign(this, opts)
			this.log('', `üîî${this.name}, ÂºÄÂßã!`)
		}

		platform() {
			if ('undefined' !== typeof $environment && $environment['surge-version'])
				return 'Surge'
			if ('undefined' !== typeof $environment && $environment['stash-version'])
				return 'Stash'
			if ('undefined' !== typeof module && !!module.exports) return 'Node.js'
			if ('undefined' !== typeof $task) return 'Quantumult X'
			if ('undefined' !== typeof $loon) return 'Loon'
			if ('undefined' !== typeof $rocket) return 'Shadowrocket'
			if ('undefined' !== typeof Egern) return 'Egern'
		}

		isQuanX() {
			return 'Quantumult X' === this.platform()
		}

		isSurge() {
			return 'Surge' === this.platform()
		}

		isLoon() {
			return 'Loon' === this.platform()
		}

		isShadowrocket() {
			return 'Shadowrocket' === this.platform()
		}

		isStash() {
			return 'Stash' === this.platform()
		}

		isEgern() {
			return 'Egern' === this.platform()
		}

		toObj(str, defaultValue = null) {
			try {
				return JSON.parse(str)
			} catch {
				return defaultValue
			}
		}

		toStr(obj, defaultValue = null) {
			try {
				return JSON.stringify(obj)
			} catch {
				return defaultValue
			}
		}

		lodash_get(object = {}, path = "", defaultValue = undefined) {
			// translate array case to dot case, then split with .
			// a[0].b -> a.0.b -> ['a', '0', 'b']
			if (!Array.isArray(path)) path = this.toPath(path)
			const result = path.reduce((previousValue, currentValue) => {
				return Object(previousValue)[currentValue] // null undefined get attribute will throwError, Object() can return a object 
			}, object)
			return (result === undefined) ? defaultValue : result
		}

		lodash_set(object = {}, path = "", value) {
			if (!Array.isArray(path)) path = this.toPath(path)
			path
				.slice(0, -1)
				.reduce(
					(previousValue, currentValue, currentIndex) =>
						(Object(previousValue[currentValue]) === previousValue[currentValue])
							? previousValue[currentValue]
							: previousValue[currentValue] = (/^\d+$/.test(path[currentIndex + 1]) ? [] : {}),
					object
				)[path[path.length - 1]] = value
			return object
		}

		toPath(value) {
			return value.replace(/\[(\d+)\]/g, '.$1').split('.').filter(Boolean)
		}

		getItem(keyName = new String, defaultValue = null) {
			let keyValue = defaultValue
			// Â¶ÇÊûú‰ª• @
			switch (keyName.startsWith('@')) {
				case true:
					const { key, path } = keyName.match(/^@(?<key>[^.]+)(?:\.(?<path>.*))?$/)?.groups
					keyName = key
					let value = this.getItem(keyName, {})
					if (typeof value !== "object") value = {}
					keyValue = this.lodash_get(value, path)
					try {
						keyValue = JSON.parse(keyValue)
					} catch (e) {
						// do nothing
					}
					break
				default:
					switch (this.platform()) {
						case 'Surge':
						case 'Loon':
						case 'Stash':
						case 'Egern':
						case 'Shadowrocket':
							keyValue = $persistentStore.read(keyName)
							break
						case 'Quantumult X':
							keyValue = $prefs.valueForKey(keyName)
							break
						default:
							keyValue = this.data?.[keyName] || null
							break
					}
					try {
						keyValue = JSON.parse(keyValue)
					} catch (e) {
						// do nothing
					}
					break
			}
		return keyValue ?? defaultValue
		}

		setItem(keyName = new String, keyValue = new String) {
			let result = false
			switch (typeof keyValue) {
				case "object":
					keyValue = JSON.stringify(keyValue)
					break
				default:
					keyValue = String(keyValue)
					break
			}
			switch (keyName.startsWith('@')) {
				case true:
					const { key, path } = keyName.match(/^@(?<key>[^.]+)(?:\.(?<path>.*))?$/)?.groups
					keyName = key
					let value = this.getItem(keyName, {})
					if (typeof value !== "object") value = {}
					this.lodash_set(value, path, keyValue)
					result = this.setItem(keyName, value)
					break
				default:
					switch (this.platform()) {
						case 'Surge':
						case 'Loon':
						case 'Stash':
						case 'Egern':
						case 'Shadowrocket':
							result = $persistentStore.write(keyValue, keyName)
							break
						case 'Quantumult X':
							result =$prefs.setValueForKey(keyValue, keyName)
							break
						default:
							result = this.data?.[keyName] || null
							break
					}
					break
			}
			return result
		}

		async fetch(request = {} || "", option = {}) {
			// ÂàùÂßãÂåñÂèÇÊï∞
			switch (request.constructor) {
				case Object:
					request = { ...request, ...option }
					break
				case String:
					request = { "url": request, ...option }
					break
			}
			// Ëá™Âä®Âà§Êñ≠ËØ∑Ê±ÇÊñπÊ≥ï
			if (!request.method) {
				request.method = request.body ?? request.bodyBytes ? "POST" : "GET"
			}
			// ÁßªÈô§ËØ∑Ê±ÇÂ§¥‰∏≠ÁöÑÈÉ®ÂàÜÂèÇÊï∞, ËÆ©ÂÖ∂Ëá™Âä®ÁîüÊàê
			delete request.headers?.Host
			delete request.headers?.[":authority"]
			delete request.headers?.['Content-Length']
			delete request.headers?.['content-length']
			// ÂÆö‰πâËØ∑Ê±ÇÊñπÊ≥ïÔºàÂ∞èÂÜôÔºâ
			const method = request.method.toLocaleLowerCase()
			// Âà§Êñ≠Âπ≥Âè∞
			switch (this.platform()) {
				case 'Loon':
				case 'Surge':
				case 'Stash':
				case 'Egern':
				case 'Shadowrocket':
				default:
					// ËΩ¨Êç¢ËØ∑Ê±ÇÂèÇÊï∞
					if (request.policy) {
						if (this.isLoon()) request.node = request.policy
						if (this.isStash()) this.lodash_set(request, "headers.X-Stash-Selected-Proxy", encodeURI(request.policy))
					}
					// Á¶ÅÊ≠¢ÈáçÂÆöÂêë
					if (request.followRedirect) {
						if (this.isSurge() || this.isLoon()) request['auto-redirect'] = false
						if (this.isQuanX()) request.opts ? request.opts.redirection = false : request.opts = { redirection: false }
					}
					// ËΩ¨Êç¢ËØ∑Ê±Ç‰Ωì
					if (request.bodyBytes && !request.body) {
						request.body = request.bodyBytes
						delete request.bodyBytes
					}
					// ÂèëÈÄÅËØ∑Ê±Ç
					return await new Promise((resolve, reject) => {
						$httpClient[method](request, (error, response, body) => {
							if (error) reject(error)
							else {
								response.ok = /^2\d\d$/.test(response.status)
								response.statusCode = response.status
								if (body) {
									response.body = body
									if (request["binary-mode"] == true) response.bodyBytes = body
								}
								resolve(response)
							}
						})
					})
				case 'Quantumult X':
					// ËΩ¨Êç¢ËØ∑Ê±ÇÂèÇÊï∞
					if (request.policy) this.lodash_set(request, "opts.policy", request.policy)
					if (typeof request["auto-redirect"] === "boolean") this.lodash_set(request, "opts.redirection", request["auto-redirect"])
					// ËΩ¨Êç¢ËØ∑Ê±Ç‰Ωì
					if (request.body instanceof ArrayBuffer) {
						request.bodyBytes = request.body
						delete request.body
					} else if (ArrayBuffer.isView(request.body)) {
						request.bodyBytes = request.body.buffer.slice(request.body.byteOffset, request.body.byteLength + request.body.byteOffset)
						delete object.body
					} else if (request.body) delete request.bodyBytes
					// ÂèëÈÄÅËØ∑Ê±Ç
					return await $task.fetch(request).then(
						response => {
							response.ok = /^2\d\d$/.test(response.statusCode)
							response.status = response.statusCode
							return response
						},
						reason => Promise.reject(reason.error))
			}
		}

		/**
		 *
		 * Á§∫‰æã:$.time('yyyy-MM-dd qq HH:mm:ss.S')
		 *    :$.time('yyyyMMddHHmmssS')
		 *    y:Âπ¥ M:Êúà d:Êó• q:Â≠£ H:Êó∂ m:ÂàÜ s:Áßí S:ÊØ´Áßí
		 *    ÂÖ∂‰∏≠yÂèØÈÄâ0-4‰ΩçÂç†‰ΩçÁ¨¶„ÄÅSÂèØÈÄâ0-1‰ΩçÂç†‰ΩçÁ¨¶ÔºåÂÖ∂‰ΩôÂèØÈÄâ0-2‰ΩçÂç†‰ΩçÁ¨¶
		 * @param {string} fmt Ê†ºÂºèÂåñÂèÇÊï∞
		 * @param {number} ÂèØÈÄâ: Ê†πÊçÆÊåáÂÆöÊó∂Èó¥Êà≥ËøîÂõûÊ†ºÂºèÂåñÊó•Êúü
		 *
		 */
		time(fmt, ts = null) {
			const date = ts ? new Date(ts) : new Date()
			let o = {
				'M+': date.getMonth() + 1,
				'd+': date.getDate(),
				'H+': date.getHours(),
				'm+': date.getMinutes(),
				's+': date.getSeconds(),
				'q+': Math.floor((date.getMonth() + 3) / 3),
				'S': date.getMilliseconds()
			}
			if (/(y+)/.test(fmt))
				fmt = fmt.replace(
					RegExp.$1,
					(date.getFullYear() + '').slice(4 - RegExp.$1.length)
				)
			for (let k in o)
				if (new RegExp('(' + k + ')').test(fmt))
					fmt = fmt.replace(
						RegExp.$1,
						RegExp.$1.length == 1
							? o[k]
							: ('00' + o[k]).slice(('' + o[k]).length)
					)
			return fmt
		}

		/**
		 *
		 * @param {String} url
		 * @returns {url} Â∞Ü 'http://url.com/page?name=Adam&surname=Smith' ÊõøÊç¢‰∏∫ 'http://url.com/page'
		 */
		getBaseURL(url) {
			return url.replace(/[?#].*$/, '')
		}

		/**
		 *
		 * @param {String} url
		 * @returns {url} Âà§Êñ≠URLÊòØÂê¶‰∏∫ÁªùÂØπË∑ØÂæÑ eg. isAbsoluteURL('/foo/bar') // false
		 */
		isAbsoluteURL(str) {
			return /^[a-z][a-z0-9+.-]*:/.test(str)
		}

		/**
		 *
		 * @param {String} url
		 * @returns {url} Â∞Ü URL ÂèÇÊï∞ËΩ¨Êç¢‰∏∫ÂØπË±° eg. getURLParameters('http://url.com/page?name=Adam&surname=Smith') // {name: 'Adam', surname: 'Smith'}
		 */
		getURLParameters(url) {
			return (url.match(/([^?=&]+)(=([^&]*))/g) || []).reduce(
				(a, v) => (
					(a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1)), a
				),
				{}
			)
		}

		/**
		 *
		 * @param {Date} date
		 * @returns {url} ‰ªéÊó•ÊúüÁîüÊàê UNIX Êó∂Èó¥Êà≥
		 */
		getTimestamp(date = new Date()) {
			return Math.floor(date.getTime() / 1000)
		}

		/**
		 *
		 * @param {Object} options
		 * @returns {String} Â∞Ü Object ÂØπË±° ËΩ¨Êç¢Êàê queryStr: key=val&name=senku
		 */
		queryStr(options) {
			let params = []
			for (let key in options) {
				if (options.hasOwnProperty(key)) {
					params.push(`${key}=${options[key]}`)
				}
			}
			let queryString = params.join('&')
			return queryString
		}

		/**
		 *
		 * @param {String} options
		 * @returns {Object} Â∞Ü queryStr: key=val&name=senku Â≠óÁ¨¶‰∏≤ ËΩ¨Êç¢Êàê Object
		 */
		queryObj(options) {
			let obj = {}
			let pairs = options.split('&')
			for (let pair of pairs) {
				let keyValue = pair.split('=')
				let key = keyValue[0]
				let value = keyValue[1] || ''
				if (key) {
					obj[key] = value
				}
			}
			return obj
		}

		/**
		 * Á≥ªÁªüÈÄöÁü•
		 *
		 * > ÈÄöÁü•ÂèÇÊï∞: ÂêåÊó∂ÊîØÊåÅ QuanX Âíå Loon ‰∏§ÁßçÊ†ºÂºè, EnvJsÊ†πÊçÆËøêË°åÁéØÂ¢ÉËá™Âä®ËΩ¨Êç¢, Surge ÁéØÂ¢É‰∏çÊîØÊåÅÂ§öÂ™í‰ΩìÈÄöÁü•
		 *
		 * Á§∫‰æã:
		 * $.msg(title, subt, desc, 'twitter://')
		 * $.msg(title, subt, desc, { 'open-url': 'twitter://', 'media-url': 'https://github.githubassets.com/images/modules/open_graph/github-mark.png' })
		 * $.msg(title, subt, desc, { 'open-url': 'https://bing.com', 'media-url': 'https://github.githubassets.com/images/modules/open_graph/github-mark.png' })
		 *
		 * @param {*} title Ê†áÈ¢ò
		 * @param {*} subt ÂâØÊ†áÈ¢ò
		 * @param {*} desc ÈÄöÁü•ËØ¶ÊÉÖ
		 * @param {*} opts ÈÄöÁü•ÂèÇÊï∞
		 *
		 */
		msg(title = this.name, subt = '', desc = '', opts) {
			const toEnvOpts = rawopts => {
				switch (typeof rawopts) {
					case undefined:
						return rawopts
					case 'string':
						switch (this.platform()) {
							case 'Surge':
							case 'Stash':
							case 'Egern':
							default:
								return { url: rawopts }
							case 'Loon':
							case 'Shadowrocket':
								return rawopts
							case 'Quantumult X':
								return { 'open-url': rawopts }
						}
					case 'object':
						switch (this.platform()) {
							case 'Surge':
							case 'Stash':
							case 'Egern':
							case 'Shadowrocket':
							default: {
								let openUrl =
									rawopts.url || rawopts.openUrl || rawopts['open-url']
								return { url: openUrl }
							}
							case 'Loon': {
								let openUrl =
									rawopts.openUrl || rawopts.url || rawopts['open-url']
								let mediaUrl = rawopts.mediaUrl || rawopts['media-url']
								return { openUrl, mediaUrl }
							}
							case 'Quantumult X': {
								let openUrl =
									rawopts['open-url'] || rawopts.url || rawopts.openUrl
								let mediaUrl = rawopts['media-url'] || rawopts.mediaUrl
								let updatePasteboard =
									rawopts['update-pasteboard'] || rawopts.updatePasteboard
								return {
									'open-url': openUrl,
									'media-url': mediaUrl,
									'update-pasteboard': updatePasteboard
								}
							}
						}
					default:
						return undefined
				}
			}
			if (!this.isMute) {
				switch (this.platform()) {
					case 'Surge':
					case 'Loon':
					case 'Stash':
					case 'Shadowrocket':
					default:
						$notification.post(title, subt, desc, toEnvOpts(opts))
						break
					case 'Quantumult X':
						$notify(title, subt, desc, toEnvOpts(opts))
						break
				}
			}
		}

		log(...logs) {
			if (logs.length > 0) {
				this.logs = [...this.logs, ...logs]
			}
			console.log(logs.join(this.logSeparator))
		}

		logErr(err, msg) {
			switch (this.platform()) {
				case 'Surge':
				case 'Loon':
				case 'Stash':
				case 'Egern':
				case 'Shadowrocket':
				case 'Quantumult X':
				default:
					this.log('', `‚ùóÔ∏è${this.name}, ÈîôËØØ!`, err, msg)
					break
			}
		}

		wait(time) {
			return new Promise((resolve) => setTimeout(resolve, time))
		}

		done(object = {}) {
			const endTime = new Date().getTime()
			const costTime = (endTime - this.startTime) / 1000
			this.log('', `üîî${this.name}, ÁªìÊùü! üïõ ${costTime} Áßí`)
			switch (this.platform()) {
				case 'Surge':
					if (object.policy) this.lodash_set(object, "headers.X-Surge-Policy", object.policy)
					$done(object)
					break
				case 'Loon':
					if (object.policy) object.node = object.policy
					$done(object)
					break
				case 'Stash':
					if (object.policy) this.lodash_set(object, "headers.X-Stash-Selected-Proxy", encodeURI(object.policy))
					$done(object)
					break
				case 'Egern':
					$done(object)
					break
				case 'Shadowrocket':
				default:
					$done(object)
					break
				case 'Quantumult X':
					if (object.policy) this.lodash_set(object, "opts.policy", object.policy)
					// ÁßªÈô§‰∏çÂèØÂÜôÂ≠óÊÆµ
					delete object["auto-redirect"]
					delete object["auto-cookie"]
					delete object["binary-mode"]
					delete object.charset
					delete object.host
					delete object.insecure
					delete object.method // 1.4.x ‰∏çÂèØÂÜô
					delete object.opt // $task.fetch() ÂèÇÊï∞, ‰∏çÂèØÂÜô
					delete object.path // ÂèØÂÜô, ‰ΩÜ‰ºö‰∏é url ÂÜ≤Á™Å
					delete object.policy
					delete object["policy-descriptor"]
					delete object.scheme
					delete object.sessionIndex
					delete object.statusCode
					delete object.timeout
					if (object.body instanceof ArrayBuffer) {
						object.bodyBytes = object.body
						delete object.body
					} else if (ArrayBuffer.isView(object.body)) {
						object.bodyBytes = object.body.buffer.slice(object.body.byteOffset, object.body.byteLength + object.body.byteOffset)
						delete object.body
					} else if (object.body) delete object.bodyBytes
					$done(object)
					break
			}
		}
	})(name, opts)
}